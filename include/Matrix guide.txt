Итак. Стандартный двумерный массив состоит из двойного указателя, однако здесь, для возможности двойной перегрузки оператора [] создаются два класса,
один из которых представляет собой шаблон обычного массива(Array), а второй - массив из массивов(Matrix). Начнем с рассмотрения шаблона массива.

1. Шаблон массива имеет два поля: обыкновенный указатель на тип данных T и размер самого массива. Методы массива стандартные: конструктор по умолчанию,
копирующий конструктор, конструктор с возможностью инициализации массива по его размеру, функция для возврата размера массива, оператор скобок и деструктор.
Короче, ничего нового, самый простейший шаблон класса-массива. Самое интересное начинается в шаблоне класса матрицы.

2. Шаблон матрицы содержит три поля: два отведены под размерности, третье - под указатель на шаблон класса Array. Что дает такая конструкция? По сути, если
подставить вместо Array<T> поле класса массива T*, то получим T** matrix, что является обыкновенным двумерным динамическим массивом. Однако, повторяюсь,
создано два класса для возможности двойной перегрузки [], поэтому, к сожалению, без подобных конструкций типа Array<T>* matrix не обойтись. Рассмотрим 
внутреннее устройство класса. Он имеет лишь один конструктор, принимающий два параметра - размеры будущей матрицы. Первой строчкой в конструкторе инициализируется
указатель на саму матрицу( matrix = new Array<T>[size1]; ). Дефолтный конструктор в классе Array обязателен, это не получится сделать, потому что при такой
инициализации сначала вызывается именно конструктор по умолчанию. Ближайший аналог в обыкновенном двумерном массиве: matrix = new T*[size1], однако снова 
повторюсь - наш класс Array<T> уже как бы является T*. В итоге указатель matrix инициализирован некоторым количеством объектов типа Array<T>. Далее в цикле 
мы вызываем конструкторы для этих объектов. В цикле может быть непонятная для некоторых строчка - matrix[i] = *(new Array<T>(size2)). Если бы тип matrix[i] 
был бы указателем, то выделение памяти происходило бы так: matrix[i] = new Array<T>(size2). Ближайшим аналогом в обыкновенном двумерном массиве является строчка
в том же цикле: matrix[i] = new T[size2], однако здесь выделяется память под size2 элементов, а в нашем случае срабатывает конструктор. Так как выделение
памяти с помощью new возвращает указатель, придется делать его разыменование - (*new Array<T>(size2)), что теперь можно присвоить объекту matrix[i].
Ну и под конец инициализируются поля матрицы, отвечающие за размеры. Дальше все почти стандартно: функции возвращающие поля класса, деструктор, и... довольно
непонятный второй оператор []. На самом деле всё очень просто - мы возвращаем ссылку на класс-массив. Соответственно при вызове конструкции вида matrix[i][j]
сначала сработает matrix[i], который вернет нам объект-массив, находящийся в матрице в строке i, и далее сработает arr[j], который вернет нам уже элемент
текущего массива.

P.S. По-хорошему стоит добавить проверку на выход за границы массива(то есть если переданные индексы i или j оказались больше, чем возможные размеры самих
массивов) и выбрасывать исключение, но мне что-то лень это делать...
