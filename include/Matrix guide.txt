Итак. Стандартный двумерный массив состоит из двойного указателя, однако здесь, для возможности двойной перегрузки оператора [] создаются два класса,
один из которых представляет собой шаблон обычного массива(Vector), а второй - массив из массивов(Matrix). Для шаблона Vector написан отдельный гайд,
так что для полного понимания кода стоит сперва прочитать его. Здесь будем рассматривать именно шаблон класса Matrix.

Private раздел:
Содержит две размерности массива и указатель на шаблонный класс массива Vector. Указатель на Vector имитирует конструкцию обычного двумерного динамического
массива: так как Vector содержит поле массива T*, то конструкцию Vector<T>* matrix можно понимать как T** matrix, что и является двумерным массивом.

Public раздел:
Содержит основные функции матрицы, по большей части основанные на классе массива Vector. По причине ненадобности в предложенных на зачет задачах
не имеет конструктора по умолчанию и конструктора копирования.
1. Конструктор с параметрами. Заполняет поля размерностей переданными значениями. Инициализирует указатель памятью под количество объектов, равное количеству
строк в матрице. В цикле по количеству столбцов выделяет память под каждую строку матрицы.
2-3. Методы, возвращающие размеры массива.
4. Оператор[] для матрицы возвращает ссылку на определенную строку в матрице. Иными словами: при вызове где-нибудь в коде конструкции matrix[i][j] сначала
срабатывает оператор[] для матрицы, возвращающий нам i-ую строку матрицы matrix[i] как ссылку на массив типа Vector<T>. Далее, представляя matrix[i] как
Vector<T>[i], имеем: (Vector<T>[i])[j], срабатывает оператор[] для Vector, то есть у i-ой строки мы берем ссылку j-тый элемент. Таким образом осуществляется
получение элемента по двум индексам. Как и вектор, оператор[] для матрицы тоже не любит кушать индекс, превышающий размеры столбца, и тоже умеет бросаться 
исключением.
5. Ну и напоследок, обыкновенный деструктор, объяснять работу которого не имеет смысла(so easy).