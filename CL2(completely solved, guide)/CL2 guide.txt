Задача:
CL2. Реализовать класс «длинное целое число» с операциями сложения,
вычитания, умножения, деления, возведения в целую степень.

Решение:
Так как программа состоит из нескольких блоков, рассмотрим их последовательно, начиная с main.cpp.
1. Итак, main.cpp имеет три функции - генерация числа, функция потокового вывода и сама main.
	1) Генерация числа. Читает символьную строку из потока ввода, пока не нажат Enter, и записывает в массив. ВАЖНО: строка не должна содержать пробелов
	ни в конце, ни в начале, ни посередине числа! Иначе работа программы завершится с ошибкой!
	2) Потоковый вывод. Получает на вход объект класса, представляющий собой число, отрезает ему лишние незначащие нули, которые могли появиться в результате
	вычислений, и записывает посимвольно в поток.
	3) Собственно, main. Создает два вектора, инициализирует их с помощью функции генерации. Создает два объекта класса "длинное целое число", передает
	эти вектора. Вызывает различные методы класса, вычисляющие сумму, разность, умножение, деление, остаток от деления и степень. Выводит значение с помощью 
	функции потокового вывода.
2. Файл LongIntDigit.h - описание класса.
	1) Private раздел имеет два поля - знак числа и вектор, содержащий числа от старшего разряда к младшему.
	2) Public раздел содержит несколько различных конструкторов и методы, упомянутые ранее. Более подробно рассмотрим их в третьем разделе.
3. Приступим к LongIntDigit.cpp.
	1) Конструктор по умолчанию не инициализирует вектор, лишь задает знак числа положительным(здесь true = '+', false = '-').
	2) Конструктор с параметром, используемый в функции main - передает число в виде вектора. Если первый элемент не минус, выставляем знак в true и выводим
	переменную start, инициализированную ранее нулем, не меняем, иначе знак делаем false и переменной start присваиваем 1. Она отвечает за передачу в 
	вектор класса значений, то есть с какого начинать. Если первый элемент в векторе был "минус" (ведь он тоже записался, когда мы инициализировали вектор
	в мэйне), то начать запись нужно с первой ячейки, иначе с нулевой.
	3) Конструктор переноса объекта по вектору и знаку. Мало чем отличается от конструктора копирования, но был удобен при написании кода.
	4) Конструктор копирования, в общем такой же, как и предыдущий, только копирует объект целиком, а не по частям.
	5) Оператор присваивания, для возможности замены существующих объектов.
	6) Далеко внизу методы возврата массива и знака.
	7) Начнем рассмотрение огромной и сложной функции operator+. Сложение работает по принципу столбика.
		7.1) Создаем пустой объект, содержащий результат.
		7.2) Сохраняем вектора объектов и максимум из их длин(пригодится далее).
		7.3) Задаем переменные vecRes и ResSign, которые получат информацию и передадут ее в результирующий объект.
		7.4) Строка 60 - начинаем цикл от нуля до сохраненного ранее числа, содержащего максимальную длину из двух векторов.
		7.5) Строки 65-66 - при i = 0 мы сохраним по последней цифре каждого числа, при i = 1 - по предпоследней и так далее. Если же мы дошли до конца
		числа, сохраняем ноль. 
			Пример: имелись числа 123(this) и 45(recieved). 
			i = 0 : thisDigitNum = 3, rcdDigitNum = 5;
			i = 1 : thisDigitNum = 2, rcdDigitNum = 4;
			i = 2 : thisDigitNum = 1, rcdDigitNum = 0;
		7.6) Строка 68 - складывает числа thisDigitNum и rcdDigitNum, умножая их на соответствующий их числу знак, и прибавляет digitAdd(перешедший разряд).
		Число digitAdd вычисляется немного ниже: если модуль получившегося числа больше или равен 10, digitAdd получает значение 1 или -1, в зависимости
		от знака, а resDigitNum остается со своим младшим разрядом, иначе 0.
			Пример: имелись числа 95(this) и 37(recieved).
			Шаг 1: resDigitNum = 5(thisDigitNum) + 7(rcdDigitNum) + 0(digitAdd) = 12; Модуль числа больше 10, digitAdd = 1, resDigitNum = 2.
			Шаг 2: resDigitNum = 9(thisDigitNum) + 3(rcdDigitNum) + 1(digitAdd) = 13; Модуль числа больше 10, digitAdd = 1, resDigitNum = 3;
		7.7) Далее, в строке 82 постоянно вычисляется ResSign, однако актуален он будет только на последней итерации. Если и resDigitNum и digitAdd больше
		нуля, то наше число будет положительным, в противном случае ResSign примет значение false.
		7.8) Строки 86-90 - если мы складываем числа с разными знаками и результат resDigitNum отрицательный, увеличиваем его на 10, а добавка digitAdd 
		становится равной -1.
			Пример: сложим числа 7 и -9. Получим -2. Однако по идеологии данной задачи в ячейке содержатся только неотрицательные числа, так что мы 
			увеличиваем -2 на 10 и в следующий разряд передаем -1. Получим 8 и -1 в следующем разряде.
			Пример: сложим числа 77 и -9. По идее предыдущего примера, получаем 8 в младшем разряде и передаем -1 в чуть более старший. Имеем: (7-1)(8),
			или 68, что и является верным ответом.
		7.9) Записываем полученный разряд в вектор. Цикл по разрядам завершен.
		7.10) Строки 98-114 - главная хитрость сложения.
			Пример: имелись числа 12 и -98. Сложим их столбиком по методу данной программы.
			Шаг 1: resDigitNum = 2 + (-8) + 0 = -6. Модуль числа меньше 10, однако оно отрицательное, и по пункту 7.8 увеличиваем его на 10 и передаем -1 
			в следующий разряд. Имеем: resDigitNum = 4, digitAdd = -1.
			Шаг 2: resDigitNum = 1 + (-9) + (-1) = -9. Модуль числа меньше 10, однако оно отрицательное, и по пункту 7.8 увеличиваем его на 10 и передаем -1 
			в следующий разряд. Имеем: resDigitNum = 1, digitAdd = -1.
			Итого у нас получилось как бы число (-1)14. Чтобы преобразовать его в правильный вид, создаем буферный вектор, заполненный количеством нулей, 
			равным числу, которое хранит максимальную длину двух ранее упомянутых векторов, добавляем в начало единичку, вычитаем это число из буферного 
			вектора и результату присваиваем отрицательный знак. Звучит сложно, но если подумать, так оно и работает. То есть для данного примера:
			максимальная длина из 12 и 98 равна 2, значит создаем вектор из двух нулей, прибиваем в начале единицу, получаем 100. И из этого 100 вычитаем
			наше число 14, получаем 86. Присваиваем знак -, получаем -86. Итого: сложение двух чисел 12 и -98 дало нам результат -86. Верный ответ получен.
			Если же складываемые числа были положительные либо в digitAdd осталась единичка, просто добавляем ее в начало вектора.
		7.11) Возвращаем полученный результат, завершаем работу этой дикой функции.
	8) Далее - operator-. Тут объяснять по сути нечего - ведь вычитание из числа A числа B(то бишь A - B) есть ни что иное, как A +(-B). То есть всего 
	лишь меняем знак у второго числа, и обращаемся к оператору сложения.
	9) Следующий на очереди - operator*. Не буду объяснять все тонкости, расскажу общий принцип работы.
		9.1) Запускаем, значит, цикл по разрядам второго числа. Скажем, были взяты числа 567 и 43, значит цикл пройдет две итерации.
		9.2) При умножении числа с n разрядами на число с одним разрядом может получить число, содержащее максимум n + 1 разрядов, поэтому его и создаем.
		9.3) Строка 140 - берем цифру второго числа с конца. Далее цикл.
		9.4) Умножаем каждую цифру первого числа текущую цифру второго. То есть на первой итерации мы будем иметь - 5*3 6*3 7*3. Правда, делается все
		это последовательно и если например на первом шаге после вычисления 7*3 = 21 мы получаем число, больше 10 по модулю, то как и в сложении, 
		digitAdd будет хранить передаваемое в следующий разряд значение. Каждый вычисленный разряд записывается в вектор.
		9.5) К слову о том, зачем мы создавали вектор длиной на 1 больше. 
			Возьмем другой пример: умножим 46 на 3. По правилам вычисления получим : 
				18 -> 8(первый разряд, 1 в следующий)
				12 + 1 = 13 -> 3(второй разряд, 1 в следующий)
			Следующего разряда у нас уже по факту и не имеется, поэтому в конец вектора запишем эту оставшуюся единицу, сохраненную в digitAdd.
			Получим - 46*3 = 138. Верно? Абсолютно.
		9.6) Помните умножение столбиком? При умножении числа на первую цифру результат запишется прямо под числом, а дальше, при умножении на вторую цифру
		происходит смещение на 1 разряд влево. В данной задаче это достигается тем, что после вычисления разрядов вектора в его конец добавляется определенное
		количество нулей - ни одного на первом шаге, один ноль на втором и так далее.
		9.7) К результату последовательно в цикле прибавляются полученные значения(строка 160), причем знак будет положительным, если оба первоначальных
		числа были одного знака, и отрицательным в противном случае.
		9.8) Возвращаем результат, завершается работа этой не менее дикой чем оператор сложения функции.
	10) Пропуская временно операторы деления и взятия остатка, расскажу про степень. Мы уже знаем, как происходит умножение, так что в этой функции все 
	будет довольно просто для понимания - передаем параметр-степень, создаем переменную-результат, и в цикле от нуля до степени-1(да-да, обязательно вычитаем
	единичку, так как результат уже содержит в себе один экземпляр числа) умножаем его на само себя. Итого получаем число, возведенное в нужную степень.
	11) Наконец, поприветствуем обладателя премии по максимальной упоротости и сложности для понимания - функцию operator/! Не стану рассказывать о
	ней полностью, так как сам запутаюсь, поэтому расскажу поверхностно.
		11.1) Итак, снова сохраняем длины векторов. 
		11.2) Заводим вектор vecRes размера 1, который изначально будет содержать один ноль. Если наше число меньше передаваемого, как раз этот ноль и
		вернется в качестве результата.
		11.3) Объект lidDelta - буферный объект, нужен далее для сохранения вычислений. Объект lidDividend - собственно делимое(по завершению работы 
		программы будет хранить остаток от деления, но об этом позже).
		11.4) Запускаем цикл от разницы длин векторов + 1. Почему? Ответ прост - при делении числа с n разрядами на число с k разрядами может получиться
		либо число с n - k + 1 разрядами(567 / 11 = 51), либо с n - k(567 / 99 = 5).
		11.5) Вкратце, что происходит внутри цикла: предположим, мы делим 567 на 43. Изначально мы задаем переменную-делитель, которая получит значение 43.
		Потом мы подгоним ее длину к длине делимого путем пуш-бэков нулей, то есть получится 430. Блок кода строк 195-207 следит за тем, сколько раз поделилось
		число c помощью той самой буферной переменной lidDelta. Прогнав в уме первую итерацию, вы получите: resDigitNum = 1, lidDividend = 137. Закидываем 
		resDigitNum в наш вектор, продолжаем дальше. Добавлять ноль к 43 больше нет смысла, так как получится что 430 > 137. Делим 137 на 43, получаем,
		что resDigitNum = 3, lidDividend = 8. Закидываем тройку в вектор. Завершаем цикл.
		11.6) Возвращаем результат resDigitNum, записанный в result, учитываем знак так же, как и в умножении.
	12) И последний наш operator%. Он основан на делении, только в конце вернется lidDividend. Как вы могли заметить из примера в пункте 11.5, lidDividend
	действительно хранит остаток от деления 567 на 43, ведь 567 = 43 * 13 + 8 = 430 + 129 + 8 = 559 + 8 = 567.
	
Итог: это вкратце описанная работа данного класса. Если кто не понял этот текст или нужно более подробное объяснение - стучитесь в личку.